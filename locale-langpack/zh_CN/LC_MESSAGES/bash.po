msgid ""
msgstr ""
"Project-Id-Version: bash 4.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-02-11 11:19-0500\n"
"PO-Revision-Date: 2011-03-26 18:26+0000\n"
"Last-Translator: Aron Xu <Unknown>\n"
"Language-Team: Chinese (simplified) <i18n-zh@googlegroups.com>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Launchpad (build 17995)\n"
"X-Launchpad-Export-Date: 2016-04-15 04:50+0000\n"

msgid "timed out waiting for input: auto-logout\n"
msgstr " 等待输入超时：自动注销\n"

msgid "\t-%s or -o option\n"
msgstr "\t-%s 或 -o 选项\n"

msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""
"\r\n"
"malloc: %s:%d: 断言已修补\r\n"

msgid "  (wd: %s)"
msgstr "  (工作目录: %s)"

msgid " (core dumped)"
msgstr " (核心已转储)"

msgid " line "
msgstr " 行 "

msgid "$%s: cannot assign in this way"
msgstr "$%s: 无法这样赋值"

msgid "%c%c: invalid option"
msgstr "%c%c: 无效的选项"

msgid "%d: invalid file descriptor: %s"
msgstr "%d: 无效的文件描述符: %s"

msgid "%s can be invoked via "
msgstr "%s 可以被调用，通过 "

msgid "%s has null exportstr"
msgstr "%s 有空的 exportstr"

msgid "%s is %s\n"
msgstr "%s 是 %s\n"

msgid "%s is a function\n"
msgstr "%s 是函数\n"

msgid "%s is a shell builtin\n"
msgstr "%s 是 shell 内建\n"

msgid "%s is a shell keyword\n"
msgstr "%s 是 shell 关键字\n"

msgid "%s is aliased to `%s'\n"
msgstr "%s 是 `%s' 的别名\n"

msgid "%s is hashed (%s)\n"
msgstr "%s 已经哈希操作(%s)\n"

msgid "%s is not bound to any keys.\n"
msgstr "%s 未与任何键绑定。\n"

msgid "%s out of range"
msgstr "%s 越界"

msgid "%s%s%s: %s (error token is \"%s\")"
msgstr "%s%s%s: %s (错误符号是 \"%s\")"

msgid "%s: %s"
msgstr "%s: %s"

msgid "%s: %s out of range"
msgstr "%s: %s 越界"

msgid "%s: %s: bad interpreter"
msgstr "%s: %s: 解释器错误"

msgid "%s: %s: cannot open as FILE"
msgstr "%s: %s: 无法作为文件打开"

msgid "%s: %s: invalid value for trace file descriptor"
msgstr "%s: %s: 追踪文件描述符的值无效"

msgid "%s: %s: must use subscript when assigning associative array"
msgstr "%s: %s: 为关联数组赋值时必须使用下标"

msgid "%s: %s:%d: cannot allocate %lu bytes"
msgstr "%s: %s:%d: 无法分配 %lu 字节"

msgid "%s: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: %s:%d: 无法分配 %lu 字节(已分配 %lu 字节)"

msgid "%s: ambiguous job spec"
msgstr "%s: 模糊的任务声明"

msgid "%s: ambiguous redirect"
msgstr "%s: 模糊的重定向"

msgid "%s: arguments must be process or job IDs"
msgstr "%s: 参数必须是进程或任务 ID"

msgid "%s: bad network path specification"
msgstr "%s: 错误的网络路径声明"

msgid "%s: bad substitution"
msgstr "%s: 错误的替换"

msgid "%s: binary operator expected"
msgstr "%s: 需要二元表达式"

msgid "%s: cannot allocate %lu bytes"
msgstr "%s: 无法分配 %lu 字节"

msgid "%s: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: 无法分配 %lu 字节(已分配 %lu 字节)"

msgid "%s: cannot assign fd to variable"
msgstr "%s: 无法将文件描述符赋值给变量"

msgid "%s: cannot assign list to array member"
msgstr "%s: 无法将链表赋值给数组成员"

msgid "%s: cannot assign to non-numeric index"
msgstr "%s: 无法为非数字的索引赋值"

msgid "%s: cannot convert associative to indexed array"
msgstr "%s: 无法将关联数组转化为索引数组"

msgid "%s: cannot convert indexed to associative array"
msgstr "%s: 无法将索引数组转化为关联数组"

msgid "%s: cannot create: %s"
msgstr "%s: 无法创建: %s"

msgid "%s: cannot delete: %s"
msgstr "%s: 无法删除: %s"

msgid "%s: cannot destroy array variables in this way"
msgstr "%s: 无法以这种方式销毁数组变量"

msgid "%s: cannot execute binary file"
msgstr "%s: 无法执行二进制文件"

msgid "%s: cannot execute: %s"
msgstr "%s: 无法执行: %s"

msgid "%s: cannot get limit: %s"
msgstr "%s: 无法获取 limit 值: %s"

msgid "%s: cannot modify limit: %s"
msgstr "%s: 无法修改 limit 值: %s"

msgid "%s: cannot open temp file: %s"
msgstr "%s: 无法打开临时文件: %s"

msgid "%s: cannot open: %s"
msgstr "%s: 无法打开: %s"

msgid "%s: cannot overwrite existing file"
msgstr "%s: 无法覆盖已存在的文件"

msgid "%s: cannot read: %s"
msgstr "%s: 无法读取: %s"

msgid "%s: cannot unset"
msgstr "%s: 无法取消设定"

msgid "%s: cannot unset: readonly %s"
msgstr "%s: 无法取消设定: 只读 %s"

msgid "%s: command not found"
msgstr "%s: 未找到命令"

msgid "%s: error retrieving current directory: %s: %s\n"
msgstr "%s: 获取当前目录时出错: %s: %s\n"

msgid "%s: expression error\n"
msgstr "%s: 表达式错误\n"

msgid "%s: file is too large"
msgstr "%s: 文件太大"

msgid "%s: file not found"
msgstr "%s: 文件未找到"

msgid "%s: first non-whitespace character is not `\"'"
msgstr "%s: 第一个非空字符不是 `\"'"

msgid "%s: hash table empty\n"
msgstr "%s: 哈希表为空\n"

msgid "%s: history expansion failed"
msgstr "%s: 历史扩展失败"

msgid "%s: host unknown"
msgstr "%s: 未知主机"

msgid "%s: illegal option -- %c\n"
msgstr "%s: 非法选项 -- %c\n"

msgid "%s: inlib failed"
msgstr "%s: inlib 失败"

msgid "%s: integer expression expected"
msgstr "%s: 需要整数表达式"

msgid "%s: invalid action name"
msgstr "%s: 无效的动作名"

msgid "%s: invalid array origin"
msgstr "%s: 无效的数组基数"

msgid "%s: invalid associative array key"
msgstr "%s: 无效的关联数组键"

msgid "%s: invalid callback quantum"
msgstr "%s: 无效的回调量子"

msgid "%s: invalid file descriptor specification"
msgstr "%s: 无效的文件描述符声明"

msgid "%s: invalid limit argument"
msgstr "%s: 无效的 limit 参数"

msgid "%s: invalid line count"
msgstr "%s: 无效的行数"

msgid "%s: invalid option"
msgstr "%s: 无效选项"

msgid "%s: invalid option name"
msgstr "%s: 无效的选项名"

msgid "%s: invalid service"
msgstr "%s: 无效的服务"

msgid "%s: invalid shell option name"
msgstr "%s: 无效的 shell 选项名"

msgid "%s: invalid signal specification"
msgstr "%s: 无效的信号声明"

msgid "%s: invalid timeout specification"
msgstr "%s: 无效的超时声明"

msgid "%s: is a directory"
msgstr "%s: 是一个目录"

msgid "%s: job %d already in background"
msgstr "%s: 任务 %d 已在后台"

msgid "%s: job has terminated"
msgstr "%s: 任务已经终止"

msgid "%s: line %d: "
msgstr "%s: 行 %d: "

msgid "%s: missing colon separator"
msgstr "%s: 缺少冒号分隔符"

msgid "%s: no completion specification"
msgstr "%s: 没有补全声明"

msgid "%s: no job control"
msgstr "%s: 无任务控制"

msgid "%s: no such job"
msgstr "%s: 无此任务"

msgid "%s: not a function"
msgstr "%s: 不是函数"

msgid "%s: not a regular file"
msgstr "%s: 不是常规文件"

msgid "%s: not a shell builtin"
msgstr "%s: 不是 shell 内建"

msgid "%s: not an array variable"
msgstr "%s: 不是数组变量"

msgid "%s: not an indexed array"
msgstr "%s: 不是一个索引数组"

msgid "%s: not dynamically loaded"
msgstr "%s: 未以动态方式加载"

msgid "%s: not found"
msgstr "%s: 未找到"

msgid "%s: numeric argument required"
msgstr "%s: 需要数字参数"

msgid "%s: option requires an argument"
msgstr "%s: 选项需要一个参数"

msgid "%s: option requires an argument -- %c\n"
msgstr "%s: 选项需要一个参数 -- %c\n"

msgid "%s: parameter null or not set"
msgstr "%s: 参数为空或未设置"

msgid "%s: readonly function"
msgstr "%s: 只读函数"

msgid "%s: readonly variable"
msgstr "%s: 只读变量"

msgid "%s: restricted"
msgstr "%s: 受限的"

msgid "%s: restricted: cannot redirect output"
msgstr "%s: 受限的: 无法重定向输出"

msgid "%s: restricted: cannot specify `/' in command names"
msgstr "%s: 受限的: 无法在命令名中使用 `/'"

msgid "%s: substring expression < 0"
msgstr "%s: 子串表达式 < 0"

msgid "%s: unary operator expected"
msgstr "%s: 需要一元表达式"

msgid "%s: unbound variable"
msgstr "%s: 未绑定的变量"

msgid "%s: usage: "
msgstr "%s: 用法: "

msgid "(( expression ))"
msgstr "(( 表达式 ))"

msgid "(core dumped) "
msgstr "(核心已转储) "

msgid "(wd now: %s)\n"
msgstr "(当前工作目录：%s)\n"

msgid ". filename [arguments]"
msgstr ". 文件名 [参数]"

msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr "没有网络时不支持 /dev/(tcp|udp)/host/port"

msgid "/tmp must be a valid directory name"
msgstr "/tmp 必须为有效的目录名"

msgid ":"
msgstr ":"

msgid "<no current directory>"
msgstr "<无当前目录>"

msgid "ABORT instruction"
msgstr "放弃指令"

msgid "Aborting..."
msgstr "中止..."

msgid ""
"Add directories to stack.\n"
"    \n"
"    Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"将目录添加到栈中。\n"
"    \n"
"    将目录添加到目录栈顶，或着旋转栈直到当前工作目录成为\n"
"    新的栈顶。不带参数时，交换栈顶的两个目录。\n"
"    \n"
"    选项：\n"
"      -n\t抑制添加目录至栈时通常的改变目录操作，从而仅对栈\n"
"    \t进行操作。\n"
"    \n"
"    参数：\n"
"      +N\t旋转栈从而第 N 个目录(`dirs' 显示的列表中左起，从零开始)\n"
"    \t将移动到栈顶。\n"
"    \n"
"      -N\t旋转栈从而第 N 个目录(`dirs' 显示的列表中右起，从零开始)\n"
"    \t将移动到栈顶。\n"
"    \n"
"      dir\t将 DIR 目录添加到栈顶，并且使其成为当前工作目录。\n"
"    \n"
"    `dirs' 内建显示目录栈。\n"
"    \n"
"    退出状态：\n"
"    返回成功，除非使用了无效的参数或者目录转换失败。"

msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"在目录栈顶部加入一个目录，或者论询\n"
"    目录栈，是当前工作目录成为新的栈顶\n"
"    不带参数时，交换栈顶的两个目录。\n"
"    \n"
"    选项：\n"
"      -n\t抑制增加栈中目录时通常的改变目录的操作，\n"
"    \t从而只有栈被操作。\n"
"    \n"
"    参数：\n"
"      +N\t轮转栈使得第N个目录(`dirs' 的\n"
"    \t输出列表中左起，从0开始)\n"
"    \t升至栈顶。\n"
"    \n"
"      -N\t轮转栈使得第N个目录(`dirs' 的\n"
"    \t输出列表中右起，从0开始)\n"
"    \t升至栈顶\n"
"    \n"
"      dir\t添加目录至栈顶，并\n"
"    \t使其成为新的当前工作目录。\n"
"    \n"
"    `dirs' 内建命令显示目录栈."

msgid "Alarm (profile)"
msgstr "报警(总结)"

msgid "Alarm (virtual)"
msgstr "报警(虚拟)"

msgid "Alarm clock"
msgstr "闹钟"

msgid ""
"Arithmetic for loop.\n"
"    \n"
"    Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"算术 for 循环。\n"
"    \n"
"    等价于\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1、EXP2 和 EXP3都是算术表达式。如果省略任何表达式，\n"
"    则等同于使用了估值为1的表达式。\n"
"    \n"
"    退出状态：\n"
"    返回最后执行的命令的状态。"

msgid "BPT trace/trap"
msgstr "断点追踪/陷阱"

msgid "Bad system call"
msgstr "错误的系统调用"

msgid "Bogus signal"
msgstr "伪信号"

msgid "Broken pipe"
msgstr "管道破裂"

msgid "Bus error"
msgstr "总线错误"

msgid "CPU limit"
msgstr "CPU 限制"

msgid "Child death or stop"
msgstr "子进程已死或者停止"

msgid ""
"Common shell variable names and usage.\n"
"    \n"
"    BASH_VERSION\tVersion information for this Bash.\n"
"    CDPATH\tA colon-separated list of directories to search\n"
"    \t\tfor directories given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE\tThe name of the file where your command history is stored.\n"
"    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
"    HISTSIZE\tThe maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME\tThe complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
"    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
"    PATH\tA colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1\t\tThe primary prompt string.\n"
"    PS2\t\tThe secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM\tThe name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume\tNon-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars\tCharacters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""
"常用 shell 变量名称和使用。\n"
"    \n"
"    BASH_VERSION\t当前 Bash 的版本信息。\n"
"    CDPATH\t用于 `cd' 命令参数搜索的分号分隔的目录列表\n"
"    GLOBIGNORE\t路径扩展时忽略的文件名匹配模式列表，\n"
"    \t\t以分号分隔。\n"
"    HISTFILE\t您的命令历史存放的文件名称。\n"
"    HISTFILESIZE\t历史文件最多可以保存的行数。\n"
"    HISTSIZE\t一个运行的 shell 最多可以访问的历史命令行数。\n"
"    HOME\t您的登录目录的完整路径。\n"
"    HOSTNAME\t当前主机的主机名。\n"
"    HOSTTYPE\t当前版本的 BASH 在其之上运行的 CPU 类型。\n"
"    IGNOREEOF\t控制 shell 收到文件结束符作为单一输入后的\n"
"    \t\t动作。如果设定这个变量，则它的值是 shell 退出之前在\n"
"    \t\t一个空行上可以连续看到的文件结束符数量(默认为10)。\n"
"    \t\t未设定时，文件结束符标志着输入的结束。\n"
"    MACHTYPE\t描述当前运行 Bash 的系统的字符串。\n"
"    MAILCHECK\tBash 检测新邮件的频率，以秒为单位。\n"
"    MAILPATH\tBash 从中检测新邮件的文件列表，以分号分隔。\n"
"    OSTYPE\t运行 Bash 的 Unix 版本。\n"
"    PATH\t当寻找命令时搜索的目录列表，以冒号分隔。\n"
"    PROMPT_COMMAND\t打印每一个主提示符之前执行的命\n"
"    \t\t令。\n"
"    PS1\t\t主提示符字符串。\n"
"    PS2\t\t从提示符字符串。\n"
"    PWD\t\t当前目录的完整路径。\n"
"    SHELLOPTS\t已启用的 shell 选项列表，以冒号分隔。\n"
"    TERM\t当前终端类型的名称。\n"
"    TIMEFORMAT\t以关键则 `time' 显示的时间统计信息的输出\n"
"    \t\t格式。\n"
"    auto_resume\t非空时，一个单独的命令词会首先被在当前\n"
"    \t\t停止的任务列表中搜索。如果找到则该任务被置于前台。\n"
"    \t\t如果值为 `exact' 则意味着命令词必须精确匹配停止任务\n"
"    \t\t列表中的命令。如果值为 `substring' 则意味着命令词必\n"
"    \t\t须匹配任务的一个子字符串。任何其他的值意味着命令词\n"
"    \t\t必须是停止任务的一个前缀。\n"
"    histchars\t控制历史展开和快速替换的字符。第一个字符是\n"
"    \t\t历史替换字符，通常是 `!'。第二个字符是快速替换字符，\n"
"    \t\t通常是 `^'。第三个是历史注释字符，通常是 `#'。\n"
"    HISTIGNORE\t用于决定哪些命令被存入历史文件的模式\n"
"    \t\t列表，以冒号分隔。\n"

msgid "Continue"
msgstr "继续"

msgid ""
"Create a coprocess named NAME.\n"
"    \n"
"    Execute COMMAND asynchronously, with the standard output and standard\n"
"    input of the command connected via a pipe to file descriptors assigned\n"
"    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
"    The default NAME is \"COPROC\".\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of COMMAND."
msgstr ""
"创建一个以 NAME 为名的副进程。\n"
"    \n"
"    异步执行 COMMANDS 命令，在执行 shell 中的数组变量 NAME\n"
"    的 0 号和 1 号元素作为文件描述符，以一个管道连接命令\n"
"    分别作为命令的标准输出和输入设备。\n"
"    默认的 NAME 是 \"COPROC\"。\n"
"    \n"
"    退出状态：\n"
"    返回 COMMAND 命令的退出状态。"

msgid ""
"Define or display aliases.\n"
"    \n"
"    Without arguments, `alias' prints the list of aliases in the reusable\n"
"    form `alias NAME=VALUE' on standard output.\n"
"    \n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.\n"
"    \n"
"    Options:\n"
"      -p\tPrint all defined aliases in a reusable format\n"
"    \n"
"    Exit Status:\n"
"    alias returns true unless a NAME is supplied for which no alias has been\n"
"    defined."
msgstr ""
"定义或显示别名。\n"
"    \n"
"    不带参数时，`alias' 以可重用的格式\n"
"    `alias 名称=值'在标准输出设备上打印别名列表。\n"
"    \n"
"    否则，对于每个给定值的名称定义一个别名。\n"
"    值末尾的空格会使下一个词被检测\n"
"    作为别名替换展开。\n"
"    \n"
"    选项：\n"
"      -p\t以可重用的格式打印所有的已定义的别名\n"
"    \n"
"    退出状态：\n"
"    除非一个没有定义的名字被作为参数提供，否则 alias \n"
"    返回值为真。"

msgid ""
"Define shell function.\n"
"    \n"
"    Create a shell function named NAME.  When invoked as a simple command,\n"
"    NAME runs COMMANDs in the calling shell's context.  When NAME is invoked,\n"
"    the arguments are passed to the function as $1...$n, and the function's\n"
"    name is in $FUNCNAME.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is readonly."
msgstr ""
"定义 shell 函数。\n"
"    \n"
"    创建一个以 NAME 为名的 shell 函数。当作为一个简单的命令启用时，\n"
"    NAME 函数执行调用 shell 的上下文中的 COMMANDs 命令。当 NAME\n"
"    被启用时，参数作为 $1...$n 被传递给函数，函数的名字储存在变量\n"
"    $FUNCNAME 中。\n"
"    \n"
"    退出状态：\n"
"    返回成功除非 NAME 为只读。"

msgid ""
"Display directory stack.\n"
"    \n"
"    Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"显示目录栈。\n"
"    \n"
"    显示当前记住的目录列表。通过 `pushd' 命令可以将目录存入列表\n"
"    中；`popd' 命令可用于遍历列表。\n"
"    \n"
"    选项：\n"
"      -c\t删除所有元素以清空目录栈\n"
"      -l\t不打印与主目录相关的波浪号前缀的目录\n"
"      -p\t每行一个条目打印目录栈\n"
"      -v\t每行一个条目，以栈中位置为前缀打印目录栈\n"
"    \n"
"    参数：\n"
"      +N\t显示 dirs 不带选项启动时显示的目录列表左起中第\n"
"    \tN 个目录，从零开始。\n"
"    \n"
"      -N\t显示 dirs 不带选项启动时显示的目录列表右起中第\n"
"    \tN 个目录，从零开始。\n"
"    \n"
"    退出状态：\n"
"    返回成功，除非使用了无效的选项或者发生错误。"

msgid ""
"Display information about builtin commands.\n"
"    \n"
"    Displays brief summaries of builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise the list of help topics is printed.\n"
"    \n"
"    Options:\n"
"      -d\toutput short description for each topic\n"
"      -m\tdisplay usage in pseudo-manpage format\n"
"      -s\toutput only a short usage synopsis for each topic matching\n"
"    \tPATTERN\n"
"    \n"
"    Arguments:\n"
"      PATTERN\tPattern specifiying a help topic\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless PATTERN is not found or an invalid option is given."
msgstr ""
"显示内建命令的相关信息。\n"
"    \n"
"    显示内建命令的简略信息。如果指定了 PATTERN 模式，\n"
"    给出所有匹配 PATTERN 模式的命令的详细帮助，否则打\n"
"    印一个帮助主题列表\n"
"    \n"
"    选项：\n"
"      -d\t输出每个主题的简短描述\n"
"      -m\t以伪 man 手册的格式显示使用方法\n"
"      -s\t为每一个匹配 PATTERN 模式的主题仅显示一个用法\n"
"    \t简介\n"
"    \n"
"    参数：\n"
"      PATTERN\tPattern 模式指定一个帮助主题\n"
"    \n"
"    退出状态：\n"
"    返回成功，除非 PATTERN 模式没有找到或者使用了无效选项。"

msgid ""
"Display information about command type.\n"
"    \n"
"    For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    Options:\n"
"      -a\tdisplay all locations containing an executable named NAME;\n"
"    \tincludes aliases, builtins, and functions, if and only if\n"
"    \tthe `-p' option is not also used\n"
"      -f\tsuppress shell function lookup\n"
"      -P\tforce a PATH search for each NAME, even if it is an alias,\n"
"    \tbuiltin, or function, and returns the name of the disk file\n"
"    \tthat would be executed\n"
"      -p\treturns either the name of the disk file that would be executed,\n"
"    \tor nothing if `type -t NAME' would not return `file'.\n"
"      -t\toutput a single word which is one of `alias', `keyword',\n"
"    \t`function', `builtin', `file' or `', if NAME is an alias, shell\n"
"    \treserved word, shell function, shell builtin, disk file, or not\n"
"    \tfound, respectively\n"
"    \n"
"    Arguments:\n"
"      NAME\tCommand name to be interpreted.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if all of the NAMEs are found; fails if any are not found."
msgstr ""
"显示命令类型的信息。\n"
"    \n"
"    对于每一个 NAME 名称，指示如果作为命令它将如何被解释。\n"
"    \n"
"    选项：\n"
"      -a\t显示所有包含名称为 NAME 的可执行文件的位置；\n"
"    \t包括别名、内建和函数。仅当 `-p' 选项没有使用时\n"
"      -f\t抑制 shell 函数查询\n"
"      -P\t为每个 NAME 名称惊醒 PATH 路径搜索，即使它是别名、\n"
"    \t内建或函数，并且返回将被执行的磁盘上文件的名称。\n"
"      -p\t返回将被执行的磁盘上文件的名称，或者当 `type -t NAME'\n"
"    \t不返回 `file' 时，不返回任何值。\n"
"      -t\t返回下列词中的任何一个`alias'、`keyword'、\n"
"    \t`function'、`builtin'、`file'或者`'，如果 NAME 是相应的\n"
"    \t一个别名、shell 保留字、shell 函数、shell 内建、\n"
"    \t磁盘文件或没有找到。\n"
"    \n"
"    参数：\n"
"      NAME\t将要解析的命令。\n"
"    \n"
"    退出状态：\n"
"    如果所有的 NAME 命令都找到则返回成功；任何找不到则失败。"

msgid ""
"Display or execute commands from the history list.\n"
"    \n"
"    fc is used to list or edit and re-execute commands from the history list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"    Options:\n"
"      -e ENAME\tselect which editor to use.  Default is FCEDIT, then EDITOR,\n"
"    \t\tthen vi\n"
"      -l \tlist lines instead of editing\n"
"      -n\tomit line numbers when listing\n"
"      -r\treverse the order of the lines (newest listed first)\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command.\n"
"    \n"
"    Exit Status:\n"
"    Returns success or status of executed command; non-zero if an error occurs."
msgstr ""
"从历史列表中显示或者执行命令。\n"
"    \n"
"    fc 被用于从历史列表中列出或者重新编辑并执行命令。\n"
"    FIRST 和 LAST 变量可以是数字用于指定范围，或者 FIRST 可以是\n"
"    字符串，意味着以这个字符串打头的最近的一个命令。\n"
"    \n"
"    \n"
"    选项：\n"
"      -e ENAME\t选择使用哪个编辑器。默认的是 FCEDIT, 然后是 EDITOR，\n"
"    \t\t然后是 vi\n"
"      -l \t列出行而不编辑\n"
"      -n\t列举时省略行号\n"
"      -r\t反转行的顺序(最新行在前)\n"
"    \n"
"    用 `fc -s [模式=替换 ...] [命令]' 的格式，COMMAND 命令会在 OLD=NEW\n"
"    替换之后被重新执行。\n"
"    \n"
"    r='fc -s' 是一个有用的别名，这样的话输入 `r cc'会执行最后一个以 `cc'\n"
"    开头的命令，输入 `r'会重新执行最后一个命令。\n"
"    \n"
"    \n"
"    退出状态：\n"
"    返回成功，或者执行的命令的状态；如果错误发生则返回非零。"

msgid ""
"Display or manipulate the history list.\n"
"    \n"
"    Display the history list with line numbers, prefixing each modified\n"
"    entry with a `*'.  An argument of N lists only the last N entries.\n"
"    \n"
"    Options:\n"
"      -c\tclear the history list by deleting all of the entries\n"
"      -d offset\tdelete the history entry at offset OFFSET.\n"
"    \n"
"      -a\tappend history lines from this session to the history file\n"
"      -n\tread all history lines not already read from the history file\n"
"      -r\tread the history file and append the contents to the history\n"
"    \tlist\n"
"      -w\twrite the current history to the history file\n"
"    \tand append them to the history list\n"
"    \n"
"      -p\tperform history expansion on each ARG and display the result\n"
"    \twithout storing it in the history list\n"
"      -s\tappend the ARGs to the history list as a single entry\n"
"    \n"
"    If FILENAME is given, it is used as the history file.  Otherwise,\n"
"    if $HISTFILE has a value, that is used, else ~/.bash_history.\n"
"    \n"
"    If the $HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed otherwise.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"显示或操纵历史列表。\n"
"    \n"
"    带行号显示历史列表，将每个被修改的条目加上前缀 `*'。\n"
"    参数 N 会仅列出最后的 N 个条目。\n"
"    \n"
"    选项：\n"
"      -c\t删除所有条目从而清空历史列表。\n"
"      -d 偏移量\t从指定位置删除历史列表。\n"
"    \n"
"      -a\t将当前会话的历史行追加到历史文件中\n"
"      -n\t从历史文件中读取所有未被读取的行\n"
"      -r\t读取历史文件并将内容追加到历史列表中\n"
"    \t中\n"
"      -w\t将当前历史写入到历史文件中\n"
"    \t并追加到历史列表中\n"
"    \n"
"      -p\t对每一个 ARG 参数展开历史并显示结果\n"
"    \t而不存储到历史列表中\n"
"      -s\t以单条记录追加 ARG 到历史列表中\n"
"    \n"
"    如果给定了 FILENAME 文件名，则它将被作为历史文件。否则\n"
"    如果 $HISTFILE 变量有值的话使用之，不然使用 ~/.bash_history 文件。\n"
"    \n"
"    如果 $HISTTIMEFORMAT 变量被设定并且不为空，它的值会被用于\n"
"    strftime(3) 的格式字符串来打印与每一个显示的历史条目想关联的时\n"
"    间戳，否则不打印时间戳。\n"
"    \n"
"    退出状态：\n"
"    返回成功，除非使用了无效的选项或者发生错误。"

msgid ""
"Display or set file mode mask.\n"
"    \n"
"    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\n"
"    the current value of the mask.\n"
"    \n"
"    If MODE begins with a digit, it is interpreted as an octal number;\n"
"    otherwise it is a symbolic mode string like that accepted by chmod(1).\n"
"    \n"
"    Options:\n"
"      -p\tif MODE is omitted, output in a form that may be reused as input\n"
"      -S\tmakes the output symbolic; otherwise an octal number is output\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless MODE is invalid or an invalid option is given."
msgstr ""
"显示或设定文件模式掩码。\n"
"    \n"
"    设定用户文件创建掩码为 MODE 模式。如果省略了 MODE，则\n"
"    打印当前掩码的值。\n"
"    \n"
"    如果MODE 模式以数字开头，则被当作八进制数解析；否则是一个\n"
"    chmod(1) 可接收的符号模式串。\n"
"    \n"
"    选项：\n"
"      -p\t如果省略 MDOE 模式，以可重用为输入的格式输入\n"
"      -S\t以符号形式输出，否则以八进制数格式输出\n"
"    \n"
"    退出状态：\n"
"    返回成功，除非使用了无效的 MODE 模式或者选项。"

msgid ""
"Display possible completions depending on the options.\n"
"    \n"
"    Intended to be used from within a shell function generating possible\n"
"    completions.  If the optional WORD argument is supplied, matches against\n"
"    WORD are generated.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"依据选项显示可能的补完。\n"
"    \n"
"    意图在能产生可能的补完的 shell 函数内部使用。\n"
"    如果提供了可选的 WORD 参数，则产生按照 WORD\n"
"    进行的匹配。\n"
"    \n"
"    退出状态：\n"
"    除非使用了无效选项或者错误发生，否则返回成功。"

msgid ""
"Display process times.\n"
"    \n"
"    Prints the accumulated user and system times for the shell and all of its\n"
"    child processes.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"显示进程时间\n"
"    \n"
"    打印 shell 及其所有子进程的累计用户空间和\n"
"    系统空间执行时间。\n"
"    \n"
"    退出状态\n"
"    总是成功。"

msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown by\n"
"\tdirs when invoked without options, starting with zero."
msgstr ""
"显示当前记住的目录列表。 目录\n"
"    通过 `pushd' 命令加入这个列表；您可以\n"
"    使用 `popd' 命令对列表进行遍历。\n"
"    \n"
"    选项:\n"
"      -c\t删除所有元素以清除目录栈\n"
"      -l\t不打印与家目录相关的以波浪号\n"
"    \t为前缀的目录\n"
"      -p\t每行一个条目打印目录栈\n"
"      -v\t以栈位置为前缀，每行一个条目\n"
"    \t打印目录栈\n"
"    \n"
"    参数:\n"
"      +N\t以 dirs 不带选项输出的顺序显示列表从左起第N个条目，\n"
"    \t从 0 开始。\n"
"    \n"
"      -N\t以 dirs 不带选项输出的顺序显示列表从右起第N个项目，\n"
"\t从 0 开始。"

msgid "Done"
msgstr "已完成"

msgid "Done(%d)"
msgstr "已完成(%d)"

msgid "EMT instruction"
msgstr "模拟器陷阱指令"

msgid ""
"Enable and disable shell builtins.\n"
"    \n"
"    Enables and disables builtin shell commands.  Disabling allows you to\n"
"    execute a disk command which has the same name as a shell builtin\n"
"    without using a full pathname.\n"
"    \n"
"    Options:\n"
"      -a\tprint a list of builtins showing whether or not each is enabled\n"
"      -n\tdisable each NAME or display a list of disabled builtins\n"
"      -p\tprint the list of builtins in a reusable format\n"
"      -s\tprint only the names of Posix `special' builtins\n"
"    \n"
"    Options controlling dynamic loading:\n"
"      -f\tLoad builtin NAME from shared object FILENAME\n"
"      -d\tRemove a builtin loaded with -f\n"
"    \n"
"    Without options, each NAME is enabled.\n"
"    \n"
"    To use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not a shell builtin or an error occurs."
msgstr ""
"启用和禁用 shell 内建。\n"
"    \n"
"    启用和禁用 shell 的内建命令。禁用使您能够执行一个和内建\n"
"    命令同名的磁盘上的命令，而无须使用完整的路径名。\n"
"    \n"
"    \n"
"    选项：\n"
"      -a\t打印一个内建的列表，并显示其中每一个是否启用\n"
"      -n\t禁用每一个 NAME 内建或者显示一个被禁用的内建的列表\n"
"      -p\t以可重用的格式打印一个内建的列表\n"
"      -s\t仅打印Posix `special'  内建的名称\n"
"    \n"
"    控制动态加载的选项：\n"
"      -f\t从共享对象 FILENAME 文件中加载 NAME 内建\n"
"      -d\t删除以 -f 选项加载的内建\n"
"    \n"
"    不带选项时，每一个 NAME 内建都被启用。\n"
"    \n"
"    如果要使用 $PATH 中找到的 `test' 而不是 shell 内建的版本，\n"
"    输入 `enable -n test'。\n"
"    \n"
"    退出状态：\n"
"    返回成功，除非 NAME 不是一个 shell 内建或者有错误发生。"

msgid ""
"Evaluate arithmetic expression.\n"
"    \n"
"    The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to \"let EXPRESSION\".\n"
"    \n"
"    Exit Status:\n"
"    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
msgstr ""
"估值算术表达式。\n"
"    \n"
"    表达式按照算术法则进行估值。\n"
"    等价于 \"let 表达式\".\n"
"    \n"
"    退出状态\n"
"    如果表达式估值为0则返回 1；否则返回0。"

msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    This is a synonym for the \"test\" builtin, but the last argument must\n"
"    be a literal `]', to match the opening `['."
msgstr ""
"估值条件表达式。\n"
"    \n"
"    是内建命令 \"test\" 的同义词，但是最后一个参数必须是\n"
"    字符 `]'，以匹配起始的 `['。"

msgid ""
"Execute a simple command or display information about commands.\n"
"    \n"
"    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n"
"    information about the specified COMMANDs.  Can be used to invoke commands\n"
"    on disk when a function with the same name exists.\n"
"    \n"
"    Options:\n"
"      -p\tuse a default value for PATH that is guaranteed to find all of\n"
"    \tthe standard utilities\n"
"      -v\tprint a description of COMMAND similar to the `type' builtin\n"
"      -V\tprint a more verbose description of each COMMAND\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of COMMAND, or failure if COMMAND is not found."
msgstr ""
"执行一个简单命令或者显示命令的相关信息。\n"
"    \n"
"    带 ARGS 参数运行 COMMAND 命令且抑制 shell 函数查询，或显示\n"
"    指定的 COMMAND 命令的信息。可以在存在相同名称的函数定义的\n"
"    情况下被用于启动磁盘上的命令。\n"
"    \n"
"    选项：\n"
"      -p\t使用 PATH 变量的一个默认值以确保所有的标准工具\n"
"    \t都能被找到。\n"
"      -v\t打印 COMMAND 命令的描述，和 `type' 内建相似\n"
"      -V\t打印每个 COMMAND 命令的详细描述\n"
"    \n"
"    退出状态\n"
"    返回 COMMAND 命令的返回状态，或者当找不到 COMMAND 命令时失败。"

msgid ""
"Execute arguments as a shell command.\n"
"    \n"
"    Combine ARGs into a single string, use the result as input to the shell,\n"
"    and execute the resulting commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of command or success if command is null."
msgstr ""
"将参数作为 shell 命令执行。\n"
"    \n"
"    将 ARGs 合成一个字符串，用结果作为 shell 的输入，\n"
"    并且执行得到的命令。\n"
"    \n"
"    退出状态：\n"
"    以命令的状态退出，或者在命令为空的情况下返回成功。"

msgid ""
"Execute commands as long as a test does not succeed.\n"
"    \n"
"    Expand and execute COMMANDS as long as the final command in the\n"
"    `until' COMMANDS has an exit status which is not zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"当测试不同过时执行命令。\n"
"    \n"
"    `until' COMMANDS 命令的最终命令返回状态不为 0 时，\n"
"    展开并执行 COMMANDS 命令。\n"
"    \n"
"    退出状态：\n"
"    返回最后一个执行的命令的状态。"

msgid ""
"Execute commands as long as a test succeeds.\n"
"    \n"
"    Expand and execute COMMANDS as long as the final command in the\n"
"    `while' COMMANDS has an exit status of zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"只要测试成功即执行命令。\n"
"    \n"
"    只要在 `while' COMMANDS 中的最终命令返回结果为0，则\n"
"    展开并执行 COMMANDS 命令。\n"
"    \n"
"    退出状态：\n"
"    返回最后一个执行的命令的状态。"

msgid ""
"Execute commands based on conditional.\n"
"    \n"
"    The `if COMMANDS' list is executed.  If its exit status is zero, then the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of the\n"
"    entire construct is the exit status of the last command executed, or zero\n"
"    if no condition tested true.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"根据条件执行命令。\n"
"    \n"
"    `if COMMANDS'列表被执行。如果退出状态为零，则执行`then COMMANDS' \n"
"    列表。否则按顺序执行每个 `elif COMMANDS'列表，并且如果它的退出状态为\n"
"    零，则执行对应的 `then COMMANDS' 列表并且 if 命令终止。否则如果存在的\n"
"    情况下，执行 `else COMMANDS'列表。整个结构的退出状态是最后一个执行\n"
"    的命令的状态，或者如果没有条件测试为真的话，为零。\n"
"    \n"
"    退出状态：\n"
"    返回最后一个执行的命令的状态。"

msgid ""
"Execute commands based on pattern matching.\n"
"    \n"
"    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"基于模式匹配来执行命令。\n"
"    \n"
"    基于 PATTERN 模式匹配的词 WORD，有选择的执行 COMMANDS 命令。\n"
"    `|' 用于分隔多个模式。\n"
"    \n"
"    退出状态：\n"
"    返回最后一个执行的命令的状态。"

msgid ""
"Execute commands for each member in a list.\n"
"    \n"
"    The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"为列表中的每个成员执行命令。\n"
"    \n"
"    `for' 循环为列表中的每个成员执行一系列的命令。如果没有\n"
"    `in WORDS ...;'则假定使用 `in \"$@\"'。对于 WORDS 中的每\n"
"     个元素，NAME 被设定为该元素，并且执行 COMMANDS 命令。\n"
"    \n"
"    退出状态：\n"
"    返回最后执行的命令的状态。"

msgid ""
"Execute commands from a file in the current shell.\n"
"    \n"
"    Read and execute commands from FILENAME in the current shell.  The\n"
"    entries in $PATH are used to find the directory containing FILENAME.\n"
"    If any ARGUMENTS are supplied, they become the positional parameters\n"
"    when FILENAME is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed in FILENAME; fails if\n"
"    FILENAME cannot be read."
msgstr ""
"在当前 shell 中执行一个文件中的命令。\n"
"    \n"
"    在当前 shell 中读取并执行 FILENAME 文件中的命令。$PATH 变量中的\n"
"    条目被用于寻找包含 FILENAME 文件的目录。如果提供了任何的 ARGUMENTS\n"
"    参数，则它们将成为 FILENAME 文件执行时的位置参数。\n"
"    \n"
"    退出状态：\n"
"    返回 FILENAME 文件中最后一个命令的状态；如果 FILENAME 文件不可读则失败。"

msgid ""
"Execute conditional command.\n"
"    \n"
"    Returns a status of 0 or 1 depending on the evaluation of the conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries used\n"
"    by the `test' builtin, and may be combined using the following operators:\n"
"    \n"
"      ( EXPRESSION )\tReturns the value of EXPRESSION\n"
"      ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n"
"      EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"      EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of\n"
"    the operator is used as a pattern and pattern matching is performed.\n"
"    When the `=~' operator is used, the string to the right of the operator\n"
"    is matched as a regular expression.\n"
"    \n"
"    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value.\n"
"    \n"
"    Exit Status:\n"
"    0 or 1 depending on value of EXPRESSION."
msgstr ""
"执行条件命令。\n"
"    \n"
"    根据条件表达式 EXPRESSION 的估值返回状态0或1。表达式按照\n"
"    `test' 内建的相同条件组成，或者可以有下列操作符连接而成：\n"
"    \n"
"      ( EXPRESSION )\t返回 EXPRESSION 表达式的值\n"
"      ! EXPRESSION\t\t如果 EXPRESSION表达式为假则为真，否则为假\n"
"      EXPR1 && EXPR2\t如果 EXPR1 和 EXPR2 表达式均为真则为真，否则为假\n"
"      EXPR1 || EXPR2\t如果 EXPR1 和 EXPR2 表达式中有一个为真则为真，否则为假\n"
"    \n"
"    当使用 `==' 和 `!=' 操作符时，操作符右边的字符串被用作模式并且执行一个\n"
"    匹配。当使用 `=~' 操作符时，操作符右边的字符串被当作正则表达式来进行\n"
"    匹配。\n"
"    \n"
"    操作符 && 和 || 将不对 EXPR2 表达式进行估值，如果 EXPR1 表达式足够确定\n"
"    整个表达式的值。\n"
"    \n"
"    退出状态：\n"
"    根据 EXPRESSION 的值为0或1。"

msgid ""
"Execute shell builtins.\n"
"    \n"
"    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
"    lookup.  This is useful when you wish to reimplement a shell builtin\n"
"    as a shell function, but need to execute the builtin within the function.\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n"
"    not a shell builtin.."
msgstr ""
"执行 shell 内建。\n"
"    \n"
"    带参数 ARGs 执行 SHELL-BUILTIN 内建，并且不做命令查询\n"
"    在希望以 shell 函数的形式来重新实现 shell 内建，\n"
"    并且希望在函数之内执行该 shell 内建的情况下有用处。\n"
"    \n"
"    退出状态：\n"
"    以 SHELL-BUILTIN 内建的退出状态为准，或者如果 SHELL-BUILTIN不是一个 shell 内建时\n"
"    为假。."

msgid "Exit %d"
msgstr "退出 %d"

msgid ""
"Exit a login shell.\n"
"    \n"
"    Exits a login shell with exit status N.  Returns an error if not executed\n"
"    in a login shell."
msgstr ""
"退出一个登录 shell.\n"
"    \n"
"    以状态 N 退出一个登录 shell。如果不在登录 shell 中执行，则\n"
"    返回一个错误。"

msgid ""
"Exit for, while, or until loops.\n"
"    \n"
"    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\n"
"    loops.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"退出 for、while、或 until 循环\n"
"    \n"
"    退出一个 FOR、WHILE 或 UNTIL 循环。如果指定了N，则跳出N重\n"
"    循环\n"
"    \n"
"    退出状态：\n"
"    退出状态为0除非 N 不大于或等于 1。"

msgid ""
"Exit the shell.\n"
"    \n"
"    Exits the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr ""
"退出shell。\n"
"    \n"
"    以状态 N 退出 shell。  如果 N 被省略，则退出状态\n"
"    为最后一个执行的命令的退出状态。"

msgid "File limit"
msgstr "文件限制"

msgid "Floating point exception"
msgstr "浮点数异常"

msgid "GNU bash, version %s (%s)\n"
msgstr "GNU bash，版本 %s (%s)\n"

msgid "GNU bash, version %s-(%s)\n"
msgstr "GNU bash，版本 %s-(%s)\n"

msgid "GNU long options:\n"
msgstr "GNU 常选项:\n"

msgid ""
"Group commands as a unit.\n"
"    \n"
"    Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"将命令组合为一个单元。\n"
"    \n"
"    运行组中的命令集合。这是对整个命令集合\n"
"    做重定向的方法之一。\n"
"    \n"
"    退出状态：\n"
"    返回最后一个执行的命令的状态。"

msgid "HFT input data pending"
msgstr "HFT 待输入数据"

msgid "HFT monitor mode granted"
msgstr "已授予 HFT 监视模式"

msgid "HFT monitor mode retracted"
msgstr "已撤销 HFT 监视模式"

msgid "HFT sound sequence has completed"
msgstr "已完成 HFT 声音序列"

msgid "HOME not set"
msgstr "HOME 未设定"

msgid "Hangup"
msgstr "挂断"

msgid "I have no name!"
msgstr "没有名字！"

msgid "I/O ready"
msgstr "I/O 就绪"

msgid "Illegal instruction"
msgstr "非法的指令"

msgid "Information request"
msgstr "信息请求"

msgid "Interrupt"
msgstr "中断"

msgid "Killed"
msgstr "已杀死"

msgid ""
"License GPLv3+: GNU GPL version 3 or later "
"<http://gnu.org/licenses/gpl.html>\n"
msgstr "许可证 GPLv3+: GNU GPL 许可证第三版或者更新版本 <http://gnu.org/licenses/gpl.html>\n"

msgid ""
"Move job to the foreground.\n"
"    \n"
"    Place the job identified by JOB_SPEC in the foreground, making it the\n"
"    current job.  If JOB_SPEC is not present, the shell's notion of the\n"
"    current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Status of command placed in foreground, or failure if an error occurs."
msgstr ""
"将任务移至前台。\n"
"    \n"
"    将以 JOB_SPEC 标识的任务放至前台，使其成为\n"
"    当前任务。如果 JOB_SPEC 不存在，shell 观念中的当前任务 \n"
"    将被使用。\n"
"    \n"
"    退出状态：\n"
"    放至前台的命令状态，或者当错误发生时为失败。"

msgid ""
"Move jobs to the background.\n"
"    \n"
"    Place the jobs identified by each JOB_SPEC in the background, as if they\n"
"    had been started with `&'.  If JOB_SPEC is not present, the shell's notion\n"
"    of the current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"移动任务至后台。\n"
"    \n"
"    将 JOB_SPEC 标识的任务放至后台，就像它们\n"
"    是带 `&' 启动的一样。如果 JOB_SPEC 不存在，shell 观念中的\n"
"    当前任务将会被使用。\n"
"    \n"
"    退出状态：\n"
"    返回成功除非任务管理没有启用或者错误发生。"

msgid ""
"Null command.\n"
"    \n"
"    No effect; the command does nothing.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"空的命令。\n"
"    \n"
"    没有效果； 此命令不做任何操作。\n"
"    \n"
"    退出状态：\n"
"    总是成功。"

msgid "OLDPWD not set"
msgstr "OLDPWD 未设定"

msgid ""
"Parse option arguments.\n"
"    \n"
"    Getopts is used by shell procedures to parse positional parameters\n"
"    as options.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters ($0 - $9), but if\n"
"    more arguments are given, they are parsed instead.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if an option is found; fails if the end of options is\n"
"    encountered or an error occurs."
msgstr ""
"解析选项参数。\n"
"    \n"
"    Getopts 被 shell 过程用于解析可定位的参数作为选项。\n"
"    \n"
"    \n"
"    OPTSTRING 字符串包含待识别的选项字母；如果一个字母后面跟\n"
"    着分号，则该选项需要一个参数，而该参数应用空格与选项分开。\n"
"    \n"
"    \n"
"    每次启动时，getopts 会将下一个选项放到 shell 变量 $name\n"
"    中，如果 name 变量不存在则先将其初始化，而下一个待处\n"
"    理的参数序号放入 shell 变量 OPTIND 中。OPTIND 变量在每\n"
"    次 shell 或者 shell 脚本启动时都被初始化为1。当一个选项要\n"
"    求有一个参数时，getopts 将参数放入 shell 变量 OPTARG\n"
"    中。\n"
"    \n"
"    getopts 有两种报告错误的方法。如果 OPTSTRING 变量的第\n"
"    一个字符是冒号，getopts 使用沉默错误报告。在这种模式\n"
"    下，不会打印错误消息。如果看到了一个无效的选项，\n"
"    getopts 将找到的选项字符放至 OPTARG 变量中。如果一个必\n"
"    须的选项没有找到，getopts 放一个 ':' 到 NAME 变量中并且设\n"
"    置 OPTARG 变量为找到的选项字符。如果 getopts 不在沉默模\n"
"    式中，并且遇到了一个无效的选项，getopts 放置一个 '?' 到 NAME \n"
"    变量中并且取消设定 OPTARG变量。如果必须的选项没有找到，\n"
"    一个'?'会被放入 NAME变量中，OPTARG 将被取消设定，并且会\n"
"    打印一个诊断信息。\n"
"    \n"
"    如果 shell 变量 OPTERR 的值为0，getopts 禁用\n"
"    错误信息的打印，即使 OPTSTRING 变量的第一个字符不是一\n"
"    个冒号。OPTERR 的默认值为1.\n"
"    \n"
"    Getopts 通常解析可定位的参数($0 - $9)，不过如果提供了\n"
"    更多的参数，它们反而会被解析。\n"
"    \n"
"    退出状态：\n"
"    如果一个选项被找到则返回成功；如果遇到了选项的结尾或者\n"
"    有错误发生则返回失败。"

msgid ""
"Print the name of the current working directory.\n"
"    \n"
"    Options:\n"
"      -L\tprint the value of $PWD if it names the current working\n"
"    \tdirectory\n"
"      -P\tprint the physical directory, without any symbolic links\n"
"    \n"
"    By default, `pwd' behaves as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless an invalid option is given or the current directory\n"
"    cannot be read."
msgstr ""
"打印当前工作目录的名字。\n"
"    \n"
"    选项：\n"
"      -L\t打印 $PWD 变量的值，如果它命名了当前的\n"
"    \t工作目录\n"
"      -P\t打印当前的物理路径，不带有任何的符号链接\n"
"    \n"
"    默认情况下，`pwd' 的行为和带 `-L' 选项一致\n"
"    \n"
"    退出状态：\n"
"    除非使用了无效选项或者当前目录不可读，否则\n"
"    返回状态为0。"

msgid "Quit"
msgstr "退出"

msgid ""
"Read lines from a file into an array variable.\n"
"    \n"
"    A synonym for `mapfile'."
msgstr ""
"从一个文件中读取行到数组变量中\n"
"    \n"
"    一个 `mapfile'的同义词。"

msgid "Record lock"
msgstr "记录锁"

msgid ""
"Remove directories from stack.\n"
"    \n"
"    Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"从栈中删除目录。\n"
"    \n"
"    从目录栈中删除条目。不带参数时，删除栈顶目录，并改变至新的栈\n"
"    顶目录。\n"
"    \n"
"    选项：\n"
"      -n\t抑制从栈中删除目录时通常的目录变换操作，从而仅对栈\n"
"    \t进行操作。\n"
"    \n"
"    参数：\n"
"      +N\t删除第 N 个目录(`dirs' 显示的目录列表中左起，从零开始)。\n"
"    \t例如： `popd +0' 删除第一个目录，popd +1' 删除第二个。\n"
"    \n"
"      -N\t删除第 N 个目录(`dirs' 显示的目录列表中右起，从零开始)。\n"
"    \t例如： `popd -0'删除最后一个目录，，`popd -1' 删除倒数第二个。\n"
"    \n"
"    `dirs' 内建显示目录栈。\n"
"    \n"
"    退出状态：\n"
"    返回成功，除非使用了无效的参数或者目录变换失败。"

msgid ""
"Remove each NAME from the list of defined aliases.\n"
"    \n"
"    Options:\n"
"      -a\tremove all alias definitions.\n"
"    \n"
"    Return success unless a NAME is not an existing alias."
msgstr ""
"从别名定义列表中删除每一个“名字”。\n"
"    \n"
"    选项：\n"
"      -a\t删除所有的别名定义。\n"
"    \n"
"    返回成功，除非“名字“不是一个已存在的别名。"

msgid ""
"Remove jobs from current shell.\n"
"    \n"
"    Removes each JOBSPEC argument from the table of active jobs.  Without\n"
"    any JOBSPECs, the shell uses its notion of the current job.\n"
"    \n"
"    Options:\n"
"      -a\tremove all jobs if JOBSPEC is not supplied\n"
"      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
"    \tshell receives a SIGHUP\n"
"      -r\tremove only running jobs\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option or JOBSPEC is given."
msgstr ""
"从当前 shell 中删除任务。\n"
"    \n"
"    从活动任务表中删除每一个 JOBSPEC 参数。不带任何\n"
"    JOBSPEC 参数时，shell 使用观念中的当前任务。\n"
"    \n"
"    选项：\n"
"      -a\t如果不提供 JOBSPEC 参数，则删除所有任务\n"
"      -h\t标识每个 JOBSPEC 任务，从而当 shell 接收到 SIGHUP\n"
"    \t信号时不发送 SIGHUP 给指定任务\n"
"      -r\t仅删除运行中的任务\n"
"    \n"
"    退出状态：\n"
"    返回成功除非使用了无效的选项或者 JOBSPEC 声明。"

msgid ""
"Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"从目录栈中删除条目。不带参数时，删除\n"
"    栈顶目录并改变至新的栈顶目录。\n"
"    \n"
"    选项：\n"
"      -n\t抑制从栈中删除目录时通常的改变目录操作，\n"
"    \t从而只有栈被操作。\n"
"    \n"
"    参数：\n"
"      +N\t从 `dirs' 输出的列表中，\n"
"    \t删除左起第N个条目，计数从0开始。例如：`popd +0'\n"
"    \t删除第一个目录，`popd +1' 删除第二个。\n"
"    \n"
"      -N\t从 `dirs' 输出的列表中，\n"
"    \t删除右起第N个条目，计数从0开始，例如：`popd -0'\n"
"    \t删除最后一个条目，`popd -1' 删除倒数第二个。\n"
"    \n"
"    `dirs' 内建变量显示目录栈。"

msgid ""
"Replace the shell with the given command.\n"
"    \n"
"    Execute COMMAND, replacing this shell with the specified program.\n"
"    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not specified,\n"
"    any redirections take effect in the current shell.\n"
"    \n"
"    Options:\n"
"      -a name\tpass NAME as the zeroth argument to COMMAND\n"
"      -c\t\texecute COMMAND with an empty environment\n"
"      -l\t\tplace a dash in the zeroth argument to COMMAND\n"
"    \n"
"    If the command cannot be executed, a non-interactive shell exits, unless\n"
"    the shell option `execfail' is set.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless COMMAND is not found or a redirection error occurs."
msgstr ""
"使用指定命令替换 shell。\n"
"    \n"
"    执行 COMMAND 命令，以指定的程序替换这个 shell。\n"
"    ARGUMENTS 参数成为 COMMAND命令的参数。如果\n"
"    没有指定COMMAND 命令，则任何的重定向在当前 shell 中生效。\n"
"    \n"
"    选项：\n"
"      -a 名称\t作为第0个参数传递给 COMMAND 命令\n"
"      -c\t\t在一个空环境中执行 COMMAND 命令\n"
"      -l\t\t在COMMAND 命令的第0个参数中加一个短线\n"
"    \n"
"    如果命令不能被执行，则退出一个非交互式的 shell，除非\n"
"   shell 选项`execfail' 已经设定。\n"
"    \n"
"    退出状态：\n"
"    返回成功除非 COMMAND 命令没有找到或者出现一个重定向错误。"

msgid ""
"Report time consumed by pipeline's execution.\n"
"    \n"
"    Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    \n"
"    Options:\n"
"      -p\tprint the timing summary in the portable Posix format\n"
"    \n"
"    The value of the TIMEFORMAT variable is used as the output format.\n"
"    \n"
"    Exit Status:\n"
"    The return status is the return status of PIPELINE."
msgstr ""
"报告管道执行的消耗时间。\n"
"    \n"
"    执行 PIPELINE 并且打印 PIPELINE 终结时实际时间、用户 CPU 时间和系统\n"
"    CPU 时间的总结。\n"
"    \n"
"    选项：\n"
"      -p\t用可迁移的 POSIX 格式打印用时总结。\n"
"    \n"
"    TIMEFORMAT 变量的值被作为输出格式。\n"
"    \n"
"    退出状态：\n"
"    返回状态即PIPELINE 的返回状态。"

msgid ""
"Resume for, while, or until loops.\n"
"    \n"
"    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resumes the Nth enclosing loop.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"继续 for、while、或 until 循环。\n"
"    \n"
"    继续当前 FOR、WHILE 或 UNTIL 循环的下一步。\n"
"    如果指定了 N， 则继续当前的第 N 重循环。\n"
"    \n"
"    退出状态：\n"
"    退出状态为 0 除非 N 不大于或等于1。"

msgid ""
"Resume job in foreground.\n"
"    \n"
"    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the resumed job."
msgstr ""
"在前台继续任务\n"
"    \n"
"    对于 JOB_SPEC 参数来说和 `fg' 命令等同。继续一个\n"
"    停止的或者后台任务。JOB_SPEC 可以指定一个任务\n"
"    名字或任务号。在 JOB_SPEC 后加上一个 `&' 将会把\n"
"    任务放至后台，就像任务声明被作为 `bg' 命令的参数\n"
"    执行一样。\n"
"    \n"
"    退出状态：\n"
"    返回被继续的任务的状态。"

msgid ""
"Return a successful result.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"返回一个成功结果。\n"
"    \n"
"    退出状态：\n"
"    总是成功"

msgid ""
"Return an unsuccessful result.\n"
"    \n"
"    Exit Status:\n"
"    Always fails."
msgstr ""
"返回一个不成功的结果。\n"
"    \n"
"    退出状态：\n"
"    总是失败。"

msgid ""
"Return from a shell function.\n"
"    \n"
"    Causes a function or sourced script to exit with the return value\n"
"    specified by N.  If N is omitted, the return status is that of the\n"
"    last command executed within the function or script.\n"
"    \n"
"    Exit Status:\n"
"    Returns N, or failure if the shell is not executing a function or script."
msgstr ""
"从一个 shell 函数返回。\n"
"    \n"
"    使一个函数或者被引用的脚本以指定的返回值 N 退出。\n"
"    如果 N 被省略，则返回状态就是\n"
"    函数或脚本中的最后一个执行的命令的状态。\n"
"    \n"
"    退出状态：\n"
"    返回 N，或者如果 shell 不在执行一个函数或引用脚本时，失败。"

msgid ""
"Return the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"返回当前子调用的上下文。\n"
"    \n"
"    不带有 EXPR 时，返回 \"$line $filename\"。带有 EXPR 时，返回\n"
"    \"$line $subroutine $filename\"；这个额外的信息可以被用于提供\n"
"    栈追踪。\n"
"    \n"
"    EXPR 的值 显示了到当前调用帧需要回去多少个调用帧；顶部帧\n"
"    是第 0 帧。\n"
"    \n"
"    退出状态：\n"
"    除非 shell 不在执行一个 shell 函数或者 EXPR 无效，否则返回结\n"
"    果为0。"

msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns "
msgstr ""
"返回当前子例程调用的上下文\n"
"    \n"
"    不带 EXPR 时，返回 "

msgid "Running"
msgstr "运行中"

msgid "Segmentation fault"
msgstr "段错误"

msgid ""
"Select words from a list and execute commands.\n"
"    \n"
"    The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"从列表中选取词并且执行命令。\n"
"    \n"
"    WORDS 变量被展开，生成一个词的列表。展开的词集合被打印\n"
"    在标准错误输出设备上，每个以一个数字做前缀。如果没有 `in WORDS'\n"
"    则假定使用`in \"$@\"'。PS3提示符会被显示并且从标准输入读入一行\n"
"    如果该行由被显示的词对应的数字组成，则 NAME 变量被设定为相应\n"
"    的词。如果行为空，则 WORDS 变量和提示符被重新显示。如果读取了\n"
"    文件结束符，则命令完成。读入任何其他的值会导致 NAME 变量被设定\n"
"    为空。读入的行被存放在变量 REPLY 中。COMMANDS 命令在每次选择\n"
"    之后执行直到执行一个 break 命令。\n"
"    \n"
"    退出状态：\n"
"    返回最后一个执行的命令的状态。"

msgid ""
"Send a signal to a job.\n"
"    \n"
"    Send the processes identified by PID or JOBSPEC the signal named by\n"
"    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
"    SIGTERM is assumed.\n"
"    \n"
"    Options:\n"
"      -s sig\tSIG is a signal name\n"
"      -n sig\tSIG is a signal number\n"
"      -l\tlist the signal names; if arguments follow `-l' they are\n"
"    \tassumed to be signal numbers for which names should be listed\n"
"    \n"
"    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
"    instead of process IDs, and allows processes to be killed if the limit\n"
"    on processes that you can create is reached.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"向一个任务发送一个信号。\n"
"    \n"
"    向以 PID 进程号或者 JOBSPEC 任务声明指定的进程发送一个以\n"
"    SIGSPEC 信号声明或 SIGNUM 信号编号命名的信号。如果没有指定\n"
"    SIGSPEC 或 SIGNUM，那么假定发送 SIGTERM 信号。\n"
"    \n"
"    选项：\n"
"      -s sig\tSIG 是信号名称\n"
"      -n sig\tSIG 是信号编号\n"
"      -l\t列出信号名称；如果参数后跟 `-l'则被假设为信号编号，\n"
"    \t而相应的信号名称会被列出\n"
"    \n"
"    Kill 成为 shell 内建有两个理由：它允许使用任务编号而不是进程号，\n"
"    并且在可以创建的进程数上限达到是允许进程被杀死。\n"
"    \n"
"    退出状态：\n"
"    返回成功，除非使用了无效的选项或者有错误发生。"

msgid ""
"Set and unset shell options.\n"
"    \n"
"    Change the setting of each shell option OPTNAME.  Without any option\n"
"    arguments, list all shell options with an indication of whether or not each\n"
"    is set.\n"
"    \n"
"    Options:\n"
"      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
"      -p\tprint each shell option with an indication of its status\n"
"      -q\tsuppress output\n"
"      -s\tenable (set) each OPTNAME\n"
"      -u\tdisable (unset) each OPTNAME\n"
"    \n"
"    Exit Status:\n"
"    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
"    given or OPTNAME is disabled."
msgstr ""
"设定和取消设定 shell 选项。\n"
"    \n"
"    改变每个 shell 选项 OPTNAME的设定。不带参数\n"
"    时，列出所有 shell 选项并标注每一个选项是否被\n"
"    设定。\n"
"    \n"
"    选项：\n"
"      -o\t限制 OPTNAME 为定义用于`set -o' 的选项\n"
"      -p\t打印每个 shell 选项并标注它的状态。\n"
"      -q\t抑制输出\n"
"      -s\t启用(设定)每个 OPTNAME 选项\n"
"      -u\t禁用(取消设定)每个 OPTNAME 选项\n"
"    \n"
"    退出状态：\n"
"    如果 OPTNAME 选项被启用则返回成功；如果是\n"
"    无效的选项或OPTNAME 被禁用则失败。"

msgid ""
"Set export attribute for shell variables.\n"
"    \n"
"    Marks each NAME for automatic export to the environment of subsequently\n"
"    executed commands.  If VALUE is supplied, assign VALUE before exporting.\n"
"    \n"
"    Options:\n"
"      -f\trefer to shell functions\n"
"      -n\tremove the export property from each NAME\n"
"      -p\tdisplay a list of all exported variables and functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"为 shell 变量设定导出属性。\n"
"    \n"
"    标记每个 NAME 名称为自动导出到后续命令执行的环境。如果提供了 VALUE\n"
"    则导出前将 VALUE 作为赋值。\n"
"    \n"
"    选项：\n"
"      -f\t指 shell 函数\n"
"      -n\t删除每个 NAME 名称的导出属性\n"
"      -p\t显示所有导出的变量和函数的列表\n"
"    \n"
"    `--' 的参数禁用进一步的选项处理。\n"
"    \n"
"    退出状态：\n"
"    返回成功，除非使用了无效的选项或者 NAME 名称。"

msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Obsolete.  See `help declare'."
msgstr ""
"设置变量的值和属性。\n"
"    \n"
"    废弃。参见 `help declare'。"

msgid "Shell commands matching keyword `"
msgid_plural "Shell commands matching keywords `"
msgstr[0] "Shell 命令匹配关键字 `"

msgid "Shell options:\n"
msgstr "Shell 选项:\n"

msgid ""
"Shift positional parameters.\n"
"    \n"
"    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\n"
"    not given, it is assumed to be 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless N is negative or greater than $#."
msgstr ""
"移位位置参数。\n"
"    \n"
"    重命名位置参数 $N+1、$N+2 ... 到 $1、$2 ...  如果没有给定 N，\n"
"    则假设为1.\n"
"    \n"
"    退出状态：\n"
"    返回成功，除非 N 为负或者大于 $#。"

msgid "Signal %d"
msgstr "信号 %d"

msgid ""
"Specify how arguments are to be completed by Readline.\n"
"    \n"
"    For each NAME, specify how arguments are to be completed.  If no options\n"
"    are supplied, existing completion specifications are printed in a way that\n"
"    allows them to be reused as input.\n"
"    \n"
"    Options:\n"
"      -p\tprint existing completion specifications in a reusable format\n"
"      -r\tremove a completion specification for each NAME, or, if no\n"
"    \tNAMEs are supplied, all completion specifications\n"
"      -D\tapply the completions and actions as the default for commands\n"
"    \twithout any specific completion defined\n"
"      -E\tapply the completions and actions to \"empty\" commands --\n"
"    \tcompletion attempted on a blank line\n"
"    \n"
"    When completion is attempted, the actions are applied in the order the\n"
"    uppercase-letter options are listed above.  The -D option takes\n"
"    precedence over -E.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"声明 readline 如何完成读取参数。\n"
"    \n"
"    声明对于每一个 NAME 名称如何完成读取参数。如果不带选项，\n"
"    现有的补完声明会以可以重用为输入的格式打印出来。\n"
"    \n"
"    选项：\n"
"      -p\t以可重用的格式打印现有的补完声明。\n"
"      -r\tr对于每个 NAME 名称删除补完声明，或者如果没有提供 NAME\n"
"    \t名称，删除所有的补完声明。\n"
"      -D\t对于没有补完声明定义的命令，设定默认的补完动作\n"
"      -E\t对于 \"empty\" 命令设定补完动作，—— 对于空行的补完。\n"
"    \n"
"    尝试补完时，按照上述大写字母选项的顺序进行动作。-D 选项优先\n"
"    级高于 -E 选项。\n"
"    \n"
"    退出状态：\n"
"    返回成功，除非使用了无效的选项或者错误发生。"

msgid "Stopped"
msgstr "已停止"

msgid "Stopped (signal)"
msgstr "已停止(信号)"

msgid "Stopped (tty input)"
msgstr "已停止(tty 输入)"

msgid "Stopped (tty output)"
msgstr "已停止(tty 输出)"

msgid "Stopped(%s)"
msgstr "已停止(%s)"

msgid ""
"Suspend shell execution.\n"
"    \n"
"    Suspend the execution of this shell until it receives a SIGCONT signal.\n"
"    Unless forced, login shells cannot be suspended.\n"
"    \n"
"    Options:\n"
"      -f\tforce the suspend, even if the shell is a login shell\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"挂起 shell 执行。\n"
"    \n"
"    挂起 shell 的执行直到收到 SIGCONT 信号。\n"
"    登录 shell 不可以被挂起，除非强制执行。\n"
"    \n"
"    选项：\n"
"      -f\t强制挂起，即使是登录 shell。\n"
"    \n"
"    退出状态：\n"
"    返回成功，除非没有启用任务控制或者有错误发生。"

msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "时间格式: `%c': 无效的格式字符"

msgid "Terminated"
msgstr "已终止"

msgid "The mail in %s has been read\n"
msgstr "%s 中的邮件已被阅读\n"

msgid "There are running jobs.\n"
msgstr "有运行中的任务。\n"

msgid "There are stopped jobs.\n"
msgstr "有停止的任务。\n"

msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"这些 shell 命令是内部定义的。请输入 `help' 以获取一个列表。\n"
"输入 `help 名称' 以得到有关函数`名称'的更多信息。\n"
"使用 `info bash' 来获得关于 shell 的更多一般性信息。\n"
"使用 `man -k' 或 `info' 来获取不在列表中的命令的更多信息。\n"
"\n"
"名称旁边的星号(*)表示该命令被禁用。\n"
"\n"

msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr "请输入`%s -c \"help set\"' 以获得关于 shell 选项的更多信息\n"

msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr "请输入 `%s -c help' 以获得关于 shell 内建命令的更多信息.\n"

msgid "Unknown Signal #"
msgstr "未知信号 #"

msgid "Unknown Signal #%d"
msgstr "未知信号 #%d"

msgid "Unknown error"
msgstr "未知错误"

msgid "Unknown status"
msgstr "未知状态"

msgid "Urgent IO condition"
msgstr "紧急 I/O 状况"

msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"用法：\t%s [GNU 长选项] [选项] ...\n"
"\t%s [GNU 长选项] [选项] 脚本文件 ...\n"

msgid "Use \"%s\" to leave the shell.\n"
msgstr "使用 \"%s\" 退出 shell 。\n"

msgid "Use the `bashbug' command to report bugs.\n"
msgstr "请使用`bashbug' 命令来报告错误.\n"

msgid "User signal 1"
msgstr "用户信号1"

msgid "User signal 2"
msgstr "用户信号2"

msgid "Window changed"
msgstr "窗口已改变"

msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"写参数至标准输出设备。\n"
"    \n"
"    在标准输出设备上显示 ARGs 参数和一个换行。\n"
"    \n"
"    选项：\n"
"      -n\t不附加换行\n"
"    \n"
"    退出状态：\n"
"    除非写错误发生，否则返回成功。"

msgid "You have mail in $_"
msgstr "您在 $_ 中有邮件"

msgid "You have new mail in $_"
msgstr "您在 $_ 中有新邮件"

msgid "[ arg... ]"
msgstr "[ 参数... ]"

msgid "[[ expression ]]"
msgstr "[[ 表达式 ]]"

msgid "`%c': bad command"
msgstr "`%c': 命令错误"

msgid "`%c': invalid format character"
msgstr "`%c': 无效格式字符"

msgid "`%c': invalid symbolic mode character"
msgstr "`%c': 无效的符号状态字符"

msgid "`%c': invalid symbolic mode operator"
msgstr "`%c': 无效的符号状态运算符"

msgid "`%c': invalid time format specification"
msgstr "`%c': 无效的时间格式声明"

msgid "`%s': cannot unbind"
msgstr "`%s': 无法解除绑定"

msgid "`%s': invalid alias name"
msgstr "`%s': 无效的别名"

msgid "`%s': invalid keymap name"
msgstr "`%s': 无效的键映射名"

msgid "`%s': missing format character"
msgstr "`%s': 缺少格式字符"

msgid "`%s': not a pid or valid job spec"
msgstr "`%s': 不是有效的进程号或者任务声明"

msgid "`%s': not a valid identifier"
msgstr "`%s': 不是有效的标识符"

msgid "`%s': unknown function name"
msgstr "`%s': 未知函数名"

msgid "`)' expected"
msgstr "需要 `)'"

msgid "`)' expected, found %s"
msgstr "需要`)'，得到 %s"

msgid "`:' expected for conditional expression"
msgstr "条件表达式需要 `:'"

msgid "add_process: pid %5ld (%s) marked as still alive"
msgstr "add_process: 进程号 %5ld(%s) 标注为仍活着"

msgid "add_process: process %5ld (%s) in the_pipeline"
msgstr "add_process: 进程 %5ld(%s) 进入 the_pipeline"

msgid "alias [-p] [name[=value] ... ]"
msgstr "alias [-p] [名称[=值] ... ]"

msgid "all_local_variables: no function context at current scope"
msgstr "all_local_variables: 当前作用域中没有函数上下文"

msgid "argument"
msgstr "参数"

msgid "argument expected"
msgstr "需要参数"

msgid "array variable support required"
msgstr "需要数组变量支持"

msgid "attempted assignment to non-variable"
msgstr "尝试给非变量赋值"

msgid "bad array subscript"
msgstr "数组下标不正确"

msgid "bad command type"
msgstr "错误的命令类型"

msgid "bad connector"
msgstr "错误的条件连接符"

msgid "bad jump"
msgstr "错误的跳转"

msgid "bad substitution: no closing \"`\" in %s"
msgstr "错误的替换: 在 %s 中没有闭合的 \"`\""

msgid "bad substitution: no closing `%s' in %s"
msgstr "错误的替换: 在 %2$s 中没有闭合的 `%1$s'"

msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr "bash_execute_unix_command: 无法为命令找到键映射"

msgid "bg [job_spec ...]"
msgstr "bg [任务声明 ...]"

msgid "break [n]"
msgstr "break [n]"

msgid "bug: bad expassign token"
msgstr "错误：表达式赋值符号错误"

msgid "builtin [shell-builtin [arg ...]]"
msgstr "builtin [shell 内建 [参数 ...]]"

msgid "caller [expr]"
msgstr "caller [表达式]"

msgid "can only `return' from a function or sourced script"
msgstr "只能从函数或者源脚本返回(`return')"

msgid "can only be used in a function"
msgstr "只能在函数中使用"

msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr "无法从文件描述符 %d 为 bash 的输入获取一个新的文件描述符"

msgid "cannot create temp file for here-document: %s"
msgstr "无法为立即文档创建临时文件: %s"

msgid "cannot duplicate fd %d to fd %d"
msgstr "无法复制文件描述符 %d 到文件描述符 %d"

msgid "cannot duplicate named pipe %s as fd %d"
msgstr "无法将命名管道 %s 作为文件描述符 %d 复制"

msgid "cannot find %s in shared object %s: %s"
msgstr "无法在共享对象 %2$s 中找到 %1$s: %3$s"

msgid "cannot make child for command substitution"
msgstr "无法为命令替换创建子进程"

msgid "cannot make child for process substitution"
msgstr "无法为进程替换创建子进程"

msgid "cannot make pipe for command substitution"
msgstr "无法为命令替换创建管道"

msgid "cannot make pipe for process substitution"
msgstr "无法为进程替换创建管道"

msgid "cannot open named pipe %s for reading"
msgstr "无法打开命名管道 %s 进行读取"

msgid "cannot open named pipe %s for writing"
msgstr "无法打开命名管道 %s 进行写入"

msgid "cannot open shared object %s: %s"
msgstr "无法打开共享对象 %s: %s"

msgid "cannot redirect standard input from /dev/null: %s"
msgstr "无法从 /dev/null 重定向标准输入: %s"

msgid "cannot reset nodelay mode for fd %d"
msgstr "无法为文件描述符 %d 重置nodelay模式"

msgid "cannot set and unset shell options simultaneously"
msgstr "无法同时设定和取消设定 shell 选项"

msgid "cannot set terminal process group (%d)"
msgstr "无法设定终端进程组(%d)"

msgid "cannot simultaneously unset a function and a variable"
msgstr "无法同时取消设定一个函数和一个变量"

msgid "cannot suspend"
msgstr "无法挂起"

msgid "cannot suspend a login shell"
msgstr "无法挂起一个登录 shell"

msgid "cannot use `-f' to make functions"
msgstr "无法用 `-f' 生成函数"

msgid "cannot use more than one of -anrw"
msgstr "最多只能使用 -anrw 选项中的一个"

msgid "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"
msgstr "case 词 in [模式 [| 模式]...) 命令 ;;]... esac"

msgid "child setpgid (%ld to %ld)"
msgstr "子进程 setpgid (%ld 到 %ld)"

msgid "command [-pVv] command [arg ...]"
msgstr "command [-pVv] 命令 [参数 ...]"

msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr "command_substitute: 无法将管道复制为文件描述符1"

msgid ""
"compgen [-abcdefgjksuv] [-o option]  [-A action] [-G globpat] [-W wordlist]"
"  [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
msgstr ""
"compgen [-abcdefgjksuv] [-o 选项]  [-A 动作] [-G 全局模式] [-W 词语列表]  [-F 函数] [-C "
"命令] [-X 过滤模式] [-P 前缀] [-S 后缀] [词语]"

msgid ""
"complete [-abcdefgjksuv] [-pr] [-DE] [-o option] [-A action] [-G globpat] "
"[-W wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S "
"suffix] [name ...]"
msgstr ""
"complete [-abcdefgjksuv] [-pr] [-DE] [-o 选项] [-A 动作] [-G 全局模式] [-W 词语列表]  "
"[-F 函数] [-C 命令] [-X 过滤模式] [-P 前缀] [-S 后缀] [名称 ...]"

msgid "completion: function `%s' not found"
msgstr "补完: 未找到函数 `%s'"

msgid "compopt [-o|+o option] [-DE] [name ...]"
msgstr "compopt [-o|+o 选项] [-DE] [名称 ...]"

msgid "conditional binary operator expected"
msgstr "需要二元条件运算符"

msgid "continue [n]"
msgstr "continue [n]"

msgid "coproc [NAME] command [redirections]"
msgstr "coproc [名称] 命令 [重定向]"

msgid "could not find /tmp, please create!"
msgstr "无法找到 /tmp ，请创建"

msgid "cprintf: `%c': invalid format character"
msgstr "cprintf: `%c': 无效的格式字符"

msgid "current"
msgstr "当前"

msgid "deleting stopped job %d with process group %ld"
msgstr "删除进程组 %2$ld 中已停止的任务 %1$d"

msgid "describe_pid: %ld: no such pid"
msgstr "describe_pid: %ld: 无此进程号"

msgid "directory stack empty"
msgstr "目录栈为空"

msgid "directory stack index"
msgstr "目录栈索引"

msgid "dirs [-clpv] [+N] [-N]"
msgstr "dirs [-clpv] [+N] [-N]"

msgid "disown [-h] [-ar] [jobspec ...]"
msgstr "disown [-h] [-ar] [任务声明 ...]"

msgid "division by 0"
msgstr "除0"

msgid "dynamic loading not available"
msgstr "动态加载不可用"

msgid "echo [-n] [arg ...]"
msgstr "echo [-n] [参数 ...]"

msgid "echo [-neE] [arg ...]"
msgstr "echo [-neE] [参数 ...]"

msgid "empty array variable name"
msgstr "空数组变量名"

msgid "enable [-a] [-dnps] [-f filename] [name ...]"
msgstr "enable [-a] [-dnps] [-f 文件名] [名称 ...]"

msgid "error getting terminal attributes: %s"
msgstr "获取终端属性时出错: %s"

msgid "error importing function definition for `%s'"
msgstr "`%s' 函数定义导入错误"

msgid "error setting terminal attributes: %s"
msgstr "设定终端属性时出错: %s"

msgid "eval [arg ...]"
msgstr "eval [参数 ...]"

msgid "exec [-cl] [-a name] [command [arguments ...]] [redirection ...]"
msgstr "exec [-cl] [-a 名称] [命令 [参数 ...]] [重定向 ...]"

msgid "exit [n]"
msgstr "exit [n]"

msgid "expected `)'"
msgstr "需要 `)'"

msgid "exponent less than 0"
msgstr "指数小于0"

msgid "export [-fn] [name[=value] ...] or export -p"
msgstr "export [-fn] [名称[=值] ...] 或 export -p"

msgid "expression expected"
msgstr "需要表达式"

msgid "expression recursion level exceeded"
msgstr "表达式递归层次越界"

msgid "false"
msgstr "false"

msgid "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"
msgstr "fc [-e 编辑器名] [-lnr] [起始] [终结] 或 fc -s [模式=替换串] [命令]"

msgid "fg [job_spec]"
msgstr "fg [任务声明]"

msgid "file descriptor out of range"
msgstr "文件描述符超出范围"

msgid "filename argument required"
msgstr "需要文件名参数"

msgid "for (( exp1; exp2; exp3 )); do COMMANDS; done"
msgstr "for (( 表达式1; 表达式2; 表达式3 )); do 命令; done"

msgid "for NAME [in WORDS ... ] ; do COMMANDS; done"
msgstr "for 名称 [in 词语 ... ] ; do 命令; done"

msgid "forked pid %d appears in running job %d"
msgstr "生成的进程号 %d 显示为运行中的任务 %d"

msgid "free: called with already freed block argument"
msgstr "free: 用已经释放的块作为参数被调用"

msgid "free: called with unallocated block argument"
msgstr "free: 用未分配的块作为参数被调用"

msgid "free: start and end chunk sizes differ"
msgstr "free: 其实和末尾块大小不一致"

msgid "free: underflow detected; mh_nbytes out of range"
msgstr "free: 检测到下溢；mh_nbytes 越界"

msgid "function name { COMMANDS ; } or name () { COMMANDS ; }"
msgstr "function 名称 { 命令 ; } 或 name () { 命令 ; }"

msgid ""
"future versions of the shell will force evaluation as an arithmetic "
"substitution"
msgstr "未来版本的 shell 会强制估值为算数替换"

msgid "getcwd: cannot access parent directories"
msgstr "getcwd: 无法访问父目录"

msgid "getopts optstring name [arg]"
msgstr "getopts 选项字符串 名称 [参数]"

msgid "hash [-lr] [-p pathname] [-dt] [name ...]"
msgstr "hash [-lr] [-p 路径名] [-dt] [名称 ...]"

msgid "hashing disabled"
msgstr "已禁用哈希"

msgid "help [-dms] [pattern ...]"
msgstr "help [-dms] [模式 ...]"

msgid "here-document at line %d delimited by end-of-file (wanted `%s')"
msgstr "立即文档在第 %d 行被文件结束符分隔 (需要 `%s')"

msgid ""
"history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg "
"[arg...]"
msgstr ""
"history [-c] [-d 偏移量] [n] 或 history -anrw [文件名] 或 history -ps 参数 [参数...]"

msgid "history position"
msgstr "历史位置"

msgid "history specification"
msgstr "历史声明"

msgid "hits\tcommand\n"
msgstr "命中\t命令\n"

msgid "identifier expected after pre-increment or pre-decrement"
msgstr "预增符或预减符后应跟有标识符"

msgid ""
"if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else "
"COMMANDS; ] fi"
msgstr "if 命令; then 命令; [ elif 命令; then 命令; ]... [ else 命令; ] fi"

msgid "initialize_job_control: getpgrp failed"
msgstr "initialize_job_control: getpgrp 失败"

msgid "initialize_job_control: line discipline"
msgstr "initialize_job_control: 行规则"

msgid "initialize_job_control: setpgid"
msgstr "initialize_job_control: setpgid"

msgid "invalid arithmetic base"
msgstr "无效的算数进制"

msgid "invalid base"
msgstr "无效的基"

msgid "invalid character %d in exportstr for %s"
msgstr "%2$s 的 exportstr 中有无效的字符 %1$d"

msgid "invalid hex number"
msgstr "无效的十六进制数"

msgid "invalid number"
msgstr "无效数字"

msgid "invalid octal number"
msgstr "无效的八进制数"

msgid "invalid signal number"
msgstr "无效的信号数"

msgid "job %d started without job control"
msgstr "在不带任务控制的情况下启动了任务 %d"

msgid "job_spec [&]"
msgstr "job_spec [&]"

msgid "jobs [-lnprs] [jobspec ...] or jobs -x command [args]"
msgstr "jobs [-lnprs] [任务声明 ...] 或 jobs -x 命令 [参数]"

msgid ""
"kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l "
"[sigspec]"
msgstr "kill [-s 信号声明 | -n 信号编号 | -信号声明] 进程号 | 任务声明 ... 或 kill -l [信号声明]"

msgid "last command: %s\n"
msgstr "上一个命令: %s\n"

msgid "let arg [arg ...]"
msgstr "let 参数 [参数 ...]"

msgid "limit"
msgstr "limit"

msgid "line %d: "
msgstr "第 %d 行: "

msgid "line editing not enabled"
msgstr "未启用行编辑"

msgid "local [option] name[=value] ..."
msgstr "local [option] 名称[=值] ..."

msgid "logout\n"
msgstr "注销\n"

msgid "logout [n]"
msgstr "logout [n]"

msgid "loop count"
msgstr "循环计数"

msgid "make_here_document: bad instruction type %d"
msgstr "make_here_document: 错误的指令类型 %d"

msgid "make_local_variable: no function context at current scope"
msgstr "make_local_variable: 当前作用域中没有函数上下文"

msgid "make_redirection: redirection instruction `%d' out of range"
msgstr "make_redirection: 重定向指令 `%d' 越界"

msgid "malloc: block on free list clobbered"
msgstr "malloc: 空闲链表中的块损坏"

msgid "malloc: failed assertion: %s\n"
msgstr "malloc: 断言失败: %s\n"

msgid ""
"mapfile [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c "
"quantum] [array]"
msgstr "mapfile [-n 计数] [-O 起始序号] [-s 计数] [-t] [-u fd] [-C 回调] [-c 量子] [数组]"

msgid "migrate process to another CPU"
msgstr "迁移进程至另一个 CPU"

msgid "missing `)'"
msgstr "缺少 `)'"

msgid "missing `]'"
msgstr "缺少 `]'"

msgid "missing hex digit for \\x"
msgstr "使用了 \\x 但缺少十六进制数"

msgid "missing unicode digit for \\%c"
msgstr "使用了 \\%c 但缺少 unicode 数"

msgid "network operations not supported"
msgstr "不支持网络操作"

msgid "no `=' in exportstr for %s"
msgstr "%s 的 exportstr 中没有 `='"

msgid "no closing `%c' in %s"
msgstr "%2$s 中没有闭合的 `%1$c'"

msgid "no command found"
msgstr "未找到命令"

msgid ""
"no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr "没有与 `%s' 匹配的帮助主题。尝试 `help help' 或 `man -k %s' 或 `info %s'。"

msgid "no job control"
msgstr "无任务控制"

msgid "no job control in this shell"
msgstr "此 shell 中无任务控制"

msgid "no match: %s"
msgstr "无匹配: %s"

msgid "no other directory"
msgstr "无其他目录"

msgid "no other options allowed with `-x'"
msgstr "其他选项不能与 `-x' 同时使用"

msgid "not currently executing completion function"
msgstr "当前未执行补完功能"

msgid "not login shell: use `exit'"
msgstr "不是登录 shell: 使用 `exit'"

msgid "octal number"
msgstr "八进制数"

msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "仅在`for'， `while'， 或者`until' 循环中有意义"

msgid "pipe error"
msgstr "管道错误"

msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr "pop_scope: shell_variables 的头部不是临时环境作用域"

msgid "pop_var_context: head of shell_variables not a function context"
msgstr "pop_var_context: shell_variables 的头部不是函数上下文"

msgid "pop_var_context: no global_variables context"
msgstr "pop_var_context: 没有 global_variables 上下文"

msgid "popd [-n] [+N | -N]"
msgstr "popd [-n] [+N | -N]"

msgid "power failure imminent"
msgstr "即将停电"

msgid "print_command: bad connector `%d'"
msgstr "print_command: 错误的条件连接符 `%d'"

msgid "printf [-v var] format [arguments]"
msgstr "printf [-v var] 格式 [参数]"

msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr "progcomp_insert: %s: 空的补完声明"

msgid "programming error"
msgstr "编程错误"

msgid "pushd [-n] [+N | -N | dir]"
msgstr "pushd [-n] [+N | -N | 目录]"

msgid "pwd [-LP]"
msgstr "pwd [-LP]"

msgid ""
"read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p "
"prompt] [-t timeout] [-u fd] [name ...]"
msgstr ""
"read [-ers] [-a 数组] [-d 分隔符] [-i 缓冲区文字] [-n 读取字符数] [-N 读取字符数] [-p 提示符] [-t "
"超时] [-u 文件描述符] [名称 ...]"

msgid "read error: %d: %s"
msgstr "读错误: %d: %s"

msgid ""
"readarray [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c "
"quantum] [array]"
msgstr "readarray [-n 计数] [-O 起始序号] [-s 计数] [-t] [-u fd] [-C 回调] [-c 量子] [数组]"

msgid "readonly [-aAf] [name[=value] ...] or readonly -p"
msgstr "readonly [-aAf] [名称[=值] ...] 或 readonly -p"

msgid "realloc: called with unallocated block argument"
msgstr "realloc: 用未分配的块作为参数被调用"

msgid "realloc: start and end chunk sizes differ"
msgstr "realloc: 其实和末尾块大小不一致"

msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr "realloc: 检测到下溢；mh_nbytes 越界"

msgid "recursion stack underflow"
msgstr "递归栈下溢"

msgid "redirection error: cannot duplicate fd"
msgstr "重定向错误: 无法复制文件描述符"

msgid "register_alloc: %p already in table as allocated?\n"
msgstr "register_alloc: %p 在表中显示为已分配？\n"

msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr "register_alloc: 分配表已经充满了 FIND_ALLOC？\n"

msgid "register_free: %p already in table as free?\n"
msgstr "register_free: %p 在表中显示为已释放？\n"

msgid "restricted"
msgstr "受限的"

msgid "return [n]"
msgstr "return [n]"

msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr "run_pending_traps: trap_list[%d] 中的错误值: %p"

msgid ""
"run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr "run_pending_traps: 信号处理器是 SIG_DFL，重新发送 %d (%s) 给自己"

msgid "save_bash_input: buffer already exists for new fd %d"
msgstr "save_bash_input: 已经存在新的文件描述符 %d 的缓冲区"

msgid "select NAME [in WORDS ... ;] do COMMANDS; done"
msgstr "select NAME [in 词语 ... ;] do 命令; done"

msgid "set [-abefhkmnptuvxBCHP] [-o option-name] [--] [arg ...]"
msgstr "set [--abefhkmnptuvxBCHP] [-o 选项名] [--] [参数 ...]"

msgid "setlocale: %s: cannot change locale (%s)"
msgstr "setlocale: %s: 无法改变区域选项 (%s)"

msgid "setlocale: %s: cannot change locale (%s): %s"
msgstr "setlocale: %s: 无法改变区域选项 (%s): %s"

msgid "setlocale: LC_ALL: cannot change locale (%s)"
msgstr "setlocale: LC_ALL: 无法改变区域选项 (%s)"

msgid "setlocale: LC_ALL: cannot change locale (%s): %s"
msgstr "setlocale: LC_ALL: 无法改变区域选项 (%s): %s"

msgid "shell level (%d) too high, resetting to 1"
msgstr "shell 层次 (%d) 太高，重置为 1"

msgid "shift [n]"
msgstr "shift [n]"

msgid "shift count"
msgstr "位移计数"

msgid "shopt [-pqsu] [-o] [optname ...]"
msgstr "shopt [-pqsu] [-o] [选项名 ...]"

msgid "sigprocmask: %d: invalid operation"
msgstr "sigprocmask: %d: 无效的操作"

msgid "source filename [arguments]"
msgstr "source 文件名 [参数]"

msgid "start_pipeline: pgrp pipe"
msgstr "start_pipeline: 进程组管道"

msgid "suspend [-f]"
msgstr "suspend [-f]"

msgid "syntax error"
msgstr "语法错误"

msgid "syntax error in conditional expression"
msgstr "条件表达式中有语法错误"

msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr "条件表达式中有语法错误: 未预期的符号 `%s'"

msgid "syntax error in expression"
msgstr "表达式中有语法错误"

msgid "syntax error near `%s'"
msgstr "`%s' 附近有语法错误"

msgid "syntax error near unexpected token `%s'"
msgstr "未预期的符号 `%s' 附近有语法错误"

msgid "syntax error: `((%s))'"
msgstr "语法错误: `((%s))'"

msgid "syntax error: `;' unexpected"
msgstr "语法错误: 需要 `;'"

msgid "syntax error: arithmetic expression required"
msgstr "语法错误: 需要算数表达式"

msgid "syntax error: invalid arithmetic operator"
msgstr "语法错误: 无效的算术运算符"

msgid "syntax error: operand expected"
msgstr "语法错误: 需要操作数"

msgid "syntax error: unexpected end of file"
msgstr "语法错误: 未预期的文件结尾"

msgid "system crash imminent"
msgstr "系统即将崩溃"

msgid "test [expr]"
msgstr "test [表达式]"

msgid "time [-p] pipeline"
msgstr "time [-p] 管道"

msgid "times"
msgstr "times"

msgid "too many arguments"
msgstr "参数太多"

msgid "trap [-lp] [[arg] signal_spec ...]"
msgstr "trap [-lp] [[参数] 信号声明 ...]"

msgid "trap_handler: bad signal %d"
msgstr "trap_handler: 错误的信号 %d"

msgid "true"
msgstr "true"

msgid "type [-afptP] name [name ...]"
msgstr "type [-afptP] 名称 [名称 ...]"

msgid "typeset [-aAfFgilrtux] [-p] name[=value] ..."
msgstr "typeset [-aAfFgilrtux] [-p] 名称[=值] ..."

msgid "umask [-p] [-S] [mode]"
msgstr "umask [-p] [-S] [模式]"

msgid "unalias [-a] name [name ...]"
msgstr "unalias [-a] 名称 [名称 ...]"

msgid "unexpected EOF while looking for `]]'"
msgstr "寻找 `]]' 是遇到了未预期的文件结束符"

msgid "unexpected EOF while looking for matching `%c'"
msgstr "寻找匹配的 `%c' 是遇到了未预期的文件结束符"

msgid "unexpected EOF while looking for matching `)'"
msgstr "寻找匹配的 `)' 时遇到了未预期的文件结束符"

msgid "unexpected argument `%s' to conditional binary operator"
msgstr "二元条件运算符使用了未预期的参数 `%s'"

msgid "unexpected argument `%s' to conditional unary operator"
msgstr "一元条件运算符使用了未预期的参数 `%s'"

msgid "unexpected argument to conditional binary operator"
msgstr "二元条件运算符使用了未预期的参数"

msgid "unexpected argument to conditional unary operator"
msgstr "一元条件运算符使用了未预期的参数"

msgid "unexpected token %d in conditional command"
msgstr "条件命令中有未预期的符号 %d"

msgid "unexpected token `%c' in conditional command"
msgstr "条件命令中有未预期的符号 `%c'"

msgid "unexpected token `%s' in conditional command"
msgstr "条件命令中有未预期的符号 `%s'"

msgid "unexpected token `%s', conditional binary operator expected"
msgstr "未预期的符号 `%s'，需要二元条件运算符"

msgid "unexpected token `%s', expected `)'"
msgstr "未预期的符号 `%s' ，需要 `)'"

msgid "unknown"
msgstr "未知"

msgid "unknown command error"
msgstr "未知的命令错误"

msgid "until COMMANDS; do COMMANDS; done"
msgstr "until 命令; do 命令; done"

msgid "value too great for base"
msgstr "数值太大不可为算数进制的基"

msgid "variables - Names and meanings of some shell variables"
msgstr "variables - 一些 shell 变量的名称和含义"

msgid "wait: pid %ld is not a child of this shell"
msgstr "wait: 进程号 %ld 不是当前 shell 的子进程"

msgid "wait_for: No record of process %ld"
msgstr "wiat_for: 没有进程 %ld 的记录"

msgid "wait_for_job: job %d is stopped"
msgstr "wait_for_job: 任务 %d 已停止"

msgid "waitchld: turning on WNOHANG to avoid indefinite block"
msgstr "waitchld: 打开 WNOHANG 以避免无限阻塞"

msgid "warning: "
msgstr "警告: "

msgid "warning: %s: %s"
msgstr "警告: %s: %s"

msgid "warning: -C option may not work as you expect"
msgstr "警告: -C 选项可能不像您预期的那样工作"

msgid "warning: -F option may not work as you expect"
msgstr "警告: -F 选项可能不像您预期的那样工作"

msgid "while COMMANDS; do COMMANDS; done"
msgstr "while 命令; do 命令; done"

msgid "write error: %s"
msgstr "写错误: %s"

msgid "xtrace fd (%d) != fileno xtrace fp (%d)"
msgstr "xtrace fd (%d) != fileno xtrace fp (%d)"

msgid "xtrace_set: %d: invalid file descriptor"
msgstr "xtrace_set: %d: 无效的文件描述符"

msgid "xtrace_set: NULL file pointer"
msgstr "xtrace_set: 空的文件指针"

msgid "{ COMMANDS ; }"
msgstr "{ 命令 ; }"
